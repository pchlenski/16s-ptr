""" Scripts for solving an OTU table from a DB """

from collections import defaultdict
from typing import Tuple
import pandas as pd
import numpy as np
from .matrix_solver import OTUSolver
from .torch_solver import TorchSolver
from .database import RnaDB


def _find_candidates(sample: pd.Series, db: RnaDB) -> Tuple[pd.DataFrame, list]:
    """
    Given a sample (indexed by MD5 hash IDs), find sequences that:
    * Are in the relevant RnaDB object database
    * Have non-zero read count
    * Have multiple MD5s in a sample that can match to the same genome

    Args:
    -----
    sample: pd.Series
        A single column from an OTU table, indexed by MD5 hash IDs
    db: RnaDB
        A database object specified in database.py

    Returns:
    --------
    coverages: pd.DataFrame
        A dataframe of coverages for each MD5 hash ID after filtering
    candidates: list
        A list of genome IDs that are candidates for solving

    Raises:
    -------
    TODO
    """

    # Pass 1: find all genomes with nonzero read counts
    md5s = sample[sample > 0].index
    genome_hits = [db.find_genomes_by_md5(md5) for md5 in md5s]
    counts = defaultdict(lambda: 0)

    # Pass 2: find all genomes with more than 1 md5 matching
    for hit in genome_hits:
        for genome in hit:
            counts[genome] += 1
    genomes_filtered = [key for key in counts if counts[key] > 1]

    # Pass 3: filter to correct number
    candidates = []
    keep_md5s = set()
    for genome in genomes_filtered:
        genome_md5s = set(db[genome]["md5"].unique())
        n_seqs = len(genome_md5s)
        if n_seqs == counts[genome]:
            candidates.append(genome)
            keep_md5s = keep_md5s | genome_md5s

    # Filter table
    filtered_index = [i for i in sample.index if i in keep_md5s]

    return sample.loc[filtered_index], candidates


def solve_all(
    otu_table_path: str,
    db_path: str = None,
    left_adapter: str = None,
    right_adapter: str = None,
    torch: bool = False,
    **kwargs,
) -> Tuple[pd.DataFrame, pd.DataFrame]:
    """
    Calls all the other functions to solve a TSV of coverages with a database

    Args:
    -----
    otu_table_path: str
        Path to a TSV of coverages, indexed by MD5 hash IDs. This can be
        generated by process_samples.py
    db_path: str
        Path to a pickled RnaDB object. If not specified, will generate a new
        database from left_adapter and
        right_adapter.
    left_adapter: str
        The 3' adapter used to sequence the RNAs.
    right_adapter: str
        The 5' adapter used to sequence the RNAs.
    torch: bool
        Whether to use the torch solver. If False, will use the matrix solver.
    **kwargs: dict
        Additional arguments to pass to the solver's train() method.

    Returns:
    --------
    ptrs: pd.DataFrame
        A dataframe of inferred PTRs, indexed by genome ID and sample ID.
    abundances: pd.DataFrame
        A dataframe of inferred abundances, indexed by genome ID and sample ID.

    Raises:
    -------
    TODO
    """

    # Produce/load an RnaDB object for inference
    if db_path is not None:
        db = RnaDB(load=db_path)
    else:
        db = RnaDB(left_primer=left_adapter, right_primer=right_adapter)
    table = pd.read_table(otu_table_path, index_col=0)

    # Initialize output table
    out = pd.DataFrame(columns=["sample", "genome", "ptr", "abundance"])

    # Solve each sample
    for column in table.columns:
        sample = table[column]
        coverages, candidates = _find_candidates(sample, db)
        if len(candidates) > 0:
            # Get genome objects (containing OOR and 16S RNA coordinates)
            genomes, all_seqs = db.generate_genome_objects(candidates)

            # Reorder according to generate_genome_objects
            sample = sample.loc[all_seqs]

            # Solve for PTRs
            if torch:
                solver = TorchSolver(genomes, coverages=coverages.values)
            else:
                solver = OTUSolver(genomes, coverages=coverages.values)
            solver.train(verbose=True, **kwargs)

            # Add to output table
            out = out.append(
                pd.DataFrame(
                    {
                        "sample": column,
                        "genome": candidates,
                        "ptr": np.exp(solver.b_hat),
                        "abundance": np.exp(solver.a_hat),
                    }
                )
            )

    # Return output tables
    ptrs = out.pivot(index="genome", columns="sample", values="ptr")
    abundances = out.pivot(index="genome", columns="sample", values="abundance")

    return ptrs, abundances


def score_predictions(
    predictions: pd.DataFrame, true_values: pd.DataFrame
) -> pd.DataFrame:
    """
    Given a dataframe of predicted PTRs and a dataframe of true PTRs, compute
    the mean squared error for each sample.

    Args:
    -----
    predictions: pd.DataFrame
        A dataframe of predicted PTRs, indexed by genome ID and sample ID.
    true_values: pd.DataFrame
        A dataframe of true PTRs, indexed by genome ID and sample ID.

    Returns:
    --------
    scores: pd.DataFrame
        A dataframe of mean squared errors, indexed by sample ID.

    Raises:
    -------
    TODO
    """

    # Compute mean squared error for each sample. Going by columns gives us a
    # rudimentary degree of permutation invariance.
    scores = pd.DataFrame()
    for column in predictions.columns:
        scores[column] = np.mean(
            (predictions[column] - true_values[column]) ** 2
        )

    return scores
